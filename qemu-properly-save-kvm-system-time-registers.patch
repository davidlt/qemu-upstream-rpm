From 20a3c3095744ea65b4dfb5365efea8cdb802f7f5 Mon Sep 17 00:00:00 2001
From: Glauber Costa <glommer@redhat.com>
Date: Wed, 21 Oct 2009 10:52:46 -0400
Subject: [PATCH] properly save kvm system time msr registers

Currently, the msrs involved in setting up pvclock are not saved over
migration and/or save/restore. This patch puts their value in special
fields in our CPUState, and deal with them using vmstate.

kvm also has to account for it, by including them in the msr list
for the ioctls.

Fedora-patch: qemu-properly-save-kvm-system-time-registers.patch
Signed-off-by: Glauber Costa <glommer@redhat.com>
---
 qemu-kvm-x86.c        |   15 +++++++++++++--
 target-i386/cpu.h     |    5 ++++-
 target-i386/machine.c |    8 ++++++++
 3 files changed, 25 insertions(+), 3 deletions(-)

diff --git a/qemu-kvm-x86.c b/qemu-kvm-x86.c
index d5436b6..300e6c2 100644
--- a/qemu-kvm-x86.c
+++ b/qemu-kvm-x86.c
@@ -839,6 +839,12 @@ static int get_msr_entry(struct kvm_msr_entry *entry, CPUState *env)
         case MSR_VM_HSAVE_PA:
             env->vm_hsave     = entry->data;
             break;
+        case MSR_KVM_SYSTEM_TIME:
+            env->system_time_msr = entry->data;
+            break;
+        case MSR_KVM_WALL_CLOCK:
+            env->wall_clock_msr = entry->data;
+            break;
         default:
             printf("Warning unknown msr index 0x%x\n", entry->index);
             return 1;
@@ -847,9 +853,9 @@ static int get_msr_entry(struct kvm_msr_entry *entry, CPUState *env)
 }
 
 #ifdef TARGET_X86_64
-#define MSR_COUNT 10
+#define MSR_COUNT 12
 #else
-#define MSR_COUNT 6
+#define MSR_COUNT 8
 #endif
 
 static void set_v8086_seg(struct kvm_segment *lhs, const SegmentCache *rhs)
@@ -1007,6 +1013,8 @@ void kvm_arch_load_regs(CPUState *env)
         set_msr_entry(&msrs[n++], MSR_LSTAR  ,           env->lstar);
     }
 #endif
+    set_msr_entry(&msrs[n++], MSR_KVM_SYSTEM_TIME,  env->system_time_msr);
+    set_msr_entry(&msrs[n++], MSR_KVM_WALL_CLOCK,  env->wall_clock_msr);
 
     rc = kvm_set_msrs(env->kvm_cpu_state.vcpu_ctx, msrs, n);
     if (rc == -1)
@@ -1184,6 +1192,9 @@ void kvm_arch_save_regs(CPUState *env)
         msrs[n++].index = MSR_LSTAR;
     }
 #endif
+    msrs[n++].index = MSR_KVM_SYSTEM_TIME;
+    msrs[n++].index = MSR_KVM_WALL_CLOCK;
+
     rc = kvm_get_msrs(env->kvm_cpu_state.vcpu_ctx, msrs, n);
     if (rc == -1) {
         perror("kvm_get_msrs FAILED");
diff --git a/target-i386/cpu.h b/target-i386/cpu.h
index 08200ed..22e76ec 100644
--- a/target-i386/cpu.h
+++ b/target-i386/cpu.h
@@ -640,6 +640,9 @@ typedef struct CPUX86State {
     target_ulong fmask;
     target_ulong kernelgsbase;
 #endif
+    uint64_t system_time_msr;
+    uint64_t wall_clock_msr;
+
 
     uint64_t tsc;
 
@@ -867,7 +870,7 @@ static inline int cpu_get_time_fast(void)
 #define cpu_signal_handler cpu_x86_signal_handler
 #define cpu_list x86_cpu_list
 
-#define CPU_SAVE_VERSION 10
+#define CPU_SAVE_VERSION 11
 
 /* MMU modes definitions */
 #define MMU_MODE0_SUFFIX _kernel
diff --git a/target-i386/machine.c b/target-i386/machine.c
index ca32a92..4654508 100644
--- a/target-i386/machine.c
+++ b/target-i386/machine.c
@@ -174,6 +174,9 @@ void cpu_save(QEMUFile *f, void *opaque)
             qemu_put_be64s(f, &env->mce_banks[4*i + 3]);
         }
     }
+
+    qemu_put_be64s(f, &env->system_time_msr);
+    qemu_put_be64s(f, &env->wall_clock_msr);
  }
 
 #ifdef USE_X86LDOUBLE
@@ -405,5 +408,10 @@ int cpu_load(QEMUFile *f, void *opaque, int version_id)
             kvm_arch_load_mpstate(env);
         }
     }
+
+    if (version_id >= 11) {
+        qemu_get_be64s(f, &env->system_time_msr);
+        qemu_get_be64s(f, &env->wall_clock_msr);
+    }
     return 0;
 }
-- 
1.6.2.2

